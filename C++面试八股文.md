# C++面试八股文

主要是自己整理的一些C++面试题

## 第一章 C++基础篇

### 1. C++ 中内存分配情况

    a. 栈：由编译器管理分配和回收，存放局部变量和函数参数。
    b. 堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。
    c. 全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。常量存储区：存储常量，⼀般不允许修改。
    d. 代码区：存放程序的⼆进制代码。



### 15、堆和栈区别
栈
由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。
连续的内存空间，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。
 
⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，不会产⽣碎⽚。
栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩。
堆
由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。
不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请
⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。
堆是低地址向⾼地址扩展，空间交⼤，较为灵活。
16、函数传递参数的⼏种⽅式
值传递：形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。
指针传递：也是值传递的⼀种⽅式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进
⾏操作。
引⽤传递：实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上⾯。

### 2. C++中如何申请和释放内存/C语言

    C++中通过new来申请内存，通过delete来释放内存
    C语言中是通过 malloc来申请内存，free来释放内存

### 3. new和malloc区别是什么？
    
    a. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
    b. new 是c++中的操作符，malloc是c语言中的一个函数

    c. new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free 也不会调用析构函数

    d. 内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。

    都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。
执⾏ new 实际上执⾏两个过程：1.分配未初始化的内存空间（malloc）；2.使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。
执⾏ delete 实际上也有两个过程：1. 使⽤析构函数对对象进⾏析构；2.回收内存空间（free）。
以上也可以看出 new 和 malloc 的区别，new 得到的是经过初始化的空间，⽽ malloc 得到的是未初始化的空间。所以 new 是 new ⼀个类型，⽽ malloc 则是malloc ⼀个字节⻓度的空间。delete 和 free 同理，delete 不仅释放空间还析构对象，delete ⼀个类型，free ⼀个字节⻓度的空间。
为什么有了 malloc／free 还需要 new／delete？因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／ free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于 malloc／free，所以有了 new／delete 操作符。






### 3. C++ 中的指针参数传递和引⽤参数传递

    a. __指针参数传递本质上是值传递__，
    它所传递的是⼀个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

引⽤参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

__引⽤传递和指针传递是不同的__，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针地址，它将应⽤不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使⽤指向指针的指针或者指针引⽤。

__从编译的⻆度来讲__，程序在编译时分别将指针和引⽤添加到符号表上，符号表中记录的是变量名及变量所对应地 址。指针变量在符号表上对应的地址值为指针变量的地址值，⽽引⽤在符号表上对应的地址值为引⽤对象的地址值（与实参名字不同，地址相同）。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），⽽引⽤对象则不能修改。

### 4. C++ 中 const 和 static 关键字（定义，⽤途）

__static__  作⽤：控制变量的存储⽅式和可⻅性。

__作⽤⼀：修饰局部变量__：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。但是要注意的是，虽然⽤ static  对局部变量进⾏修饰之后，其⽣命周期以及存储空间发⽣了变化，但其作⽤域并没有改变，作⽤域还是限制在其语句块。

__作⽤⼆：修饰全部变量__：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。
__作⽤三：修饰函数__：⽤  static  修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。

__作⽤四__：修饰类：如果 C++ 中对类中的某个函数⽤ static  修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调⽤。
（补充：静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。）

__作⽤五__：类成员/类函数声明 static
+ 函数体内 static 变量的作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；
+ 在模块内的 static  全局变量可以被模块内所⽤函数访问，但不能被模块外其它函数访问；
+ 在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内；在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉；
+ 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变量。
+ static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；
+ 由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员；
+ static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。

__const 关键字：含义及实现机制__

__const 修饰基本类型数据类型__：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。在使⽤这些常量的时候，只要不改变这些常量的值即可。

__const 修饰指针变量和引⽤变量__：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变量，即指针指向为常量；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常量。

__const 应⽤到函数中__：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变量初始化 const 常量，则在函数体中，按照 const 所修饰的部分进⾏常量化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照"修饰原则"进⾏修饰，起到相应的保护作⽤。

__const 在类中的⽤法__：const 成员变量，只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构造函数的初始化列表中进⾏。const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。

__const  修饰类对象，定义常量对象__：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

__补充__：const 成员函数中如果实在想修改某个变量，可以使⽤ mutable 进⾏修饰。成员变量中如果想建⽴在整个类中都恒定的常量，应该⽤类中的枚举常量来实现或者 static const。

__C ++ 中的 const类成员函数（⽤法和意义）__

常量对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数； （原因：对象调⽤成员函数时，在形参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然， this 是⼀个常量指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号）后加了 const 关键字（void print() const;），此成员函数为常量成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值。
⾮常量对象可以调⽤类中的 const 成员函数，也可以调⽤⾮ const 成员函数。

### 5. C 和 C++ 区别 （函数/类/struct/class）

    a. __C++ 有新增的语法和关键字__
    语法的区别有头⽂件的不同和命名空间的不同，
    C++ 允许我们⾃⼰定义⾃⼰的空间， C 中不可以。
    关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new和 delete，
    ⽽且 C++ 中在指针的基础上增加了引⽤的概念，
    关键字例如 C++中还增加了 auto，explicit 体现显示和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。

    b. __函数⽅⾯ C++ 中有重载和虚函数的概念__
    C++ ⽀持函数重载⽽C语言不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++函数名字的修饰会将参数加在后⾯，例如，int  func(int,double)经过名字修饰之后会变成_func_int_double，⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。

    c. C++ 还有虚函数概念，⽤以实现多态。

    d. __类⽅⾯，C 的struct 和 C++ 的类也有很⼤不同__：
    C++ 中的 struct 不仅可以有成员变量还可以成员函数，⽽且对于 struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public，
    C++ 中除了 struct 还有 class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。

    d.C++ 中增加了模板还重⽤代码，提供了更加强⼤的 STL 标准库。
    C 的 struct 更适合看成是⼀个数据结构的实现体，⽽ C++ 的 class 更适合看成是⼀个对象的实现体。

### 6. C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等）

指针：Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从⽽有效的防⽌了 C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了 Java  程序的安全。

多重继承：C++ ⽀持多重继承但 Java 不⽀持，但⽀持⼀个类继承多个接⼝，实现 C++ 中多重继承的功能，⼜避免了 C++ 的多重继承带来的不便。
数据类型和类：Java 是完全⾯向对象的语⾔，所有的函数和变量必须是类的⼀部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。 Java 中取消了 C++ 中的 struct 和  union 。
⾃动内存管理：Java 程序中所有对象都是⽤ new 操作符建⽴在内存堆栈上，Java ⾃动进⾏⽆⽤内存回收操作，不需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。Java 中当⼀个对象不再被⽤到时， ⽆⽤内存回收器将给他们加上标签。Java ⾥⽆⽤内存回收程序是以线程⽅式在后台运⾏的，利⽤空闲时间⼯作来删除。

Java 不⽀持操作符重载。操作符重载被认为是 C++ 的突出特性。

Java 不⽀持预处理功能。C++ 在编译过程中都有⼀个预编译阶段，Java 没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。

类型转换：C++ 中有数据类型隐含转换的机制，Java 中需要限时强制类型转换。

字符串：C++中字符串是以 Null 终⽌符代表字符串的结束，⽽ Java 的字符串 是⽤类对象（string 和stringBuffer）来实现的。

Java 中不提供 goto 语句，虽然指定 goto 作为关键字，但不⽀持它的使⽤，使程序简洁易读。

Java 的异常机制⽤于捕获例外事件，增强系统容错能⼒。

### 7. 说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？

    对于局部常量，存放在栈区；

    对于全局常量，编译期⼀般不分配内存，放在符号表中以提⾼访问效率；字⾯值常量，⽐如字符串，放在常量区。

### 8. C++ 中重载和重写，重定义的区别

    a. __重载__
    是指同⼀可访问区内被声明的⼏个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰会将参数加在后⾯，可以是参数类型，个数，顺序的不同。根据参数列表决定调⽤哪个函数，重载不关⼼函数的返回类型。

    b. __重写__
    派⽣类中重新定义⽗类中除了函数体外完全相同的虚函数，注意被重写的函数不能是 static 的，
    ⼀定要是虚函数，且其他⼀定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管 virtual 中是 private 的，派⽣类中重写可以改为 public。

    c. __重定义（隐藏）__
    派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同，即⽗类中除了定义成 virtual 且完全相同的同名函数才不会被派⽣类中的同名函数所隐藏（重定义）。

### 9. 介绍 C++ 所有的构造函数

类的对象被创建时，编译系统为对象分配内存空间，并⾃动调⽤构造函数，由构造函数完成成员的初始化⼯作。即构造函数的作⽤：初始化对象的数据成员。

__⽆参数构造函数__：即默认构造函数，如果没有明确写出⽆参数构造函数，编译器会⾃动⽣成默认的⽆参数构造函数，函数为空，什么也不做，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数。

__⼀般构造函数__：也称重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，前提是参数的个数或者类型不同，创建对象时根据传⼊参数不同调⽤不同的构造函数。

__拷⻉构造函数__：拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函 数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏深拷⻉。

__类型转换构造函数__：根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。

__赋值运算符的重载__：注意，这个类似拷⻉构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会⽣成默认的赋值运算 符，做⼀些基本的拷⻉⼯作。
这⾥区分
```.cpp {.line-numbers}
A a1,A a2;a1 = a2;// 调用赋值运算符
A a3 = a1;//调用拷贝构造函数，因为进行的是初始化工作，a3并未存在
```

### 10. C++ 的四种强制转换

C++ 的四种强制转换包括：static_cast, dynamic_cast, const_cast, reinterpret_cast

+ static_cast：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换
（派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；
+ dynamic_cast：专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。

+ const_cast：专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。                                 
+ reinterpret_cast：不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解
释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换。

### 11. 指针和引⽤的区别
指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。在程序编译的时候，将指针和引⽤添加到符号表中。
指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。
⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将"引⽤变量名-引⽤对象的地址"添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。
sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。
作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变量的地址。

### 12. 简单说⼀下函数指针
从定义和⽤途两⽅⾯来说⼀下⾃⼰的理解：
⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。
在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。
其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。示例：


### 21、⾯向对象的三⼤特性，并举例说明
C++ ⾯向对象的三⼤特征是：封装、继承、多态。
所谓封装
就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分。
所谓继承
是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能
⼒：它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。
继承概念的实现⽅式有两类：
实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。
接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒。
所谓多态
就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个接⼝，可以实现多种
⽅法。
多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。
### 多态的实现
多态其实⼀般就是指继承加虚函数实现的多态，对于重载来说，实际上基于的原理是，编译器为函数⽣成符号表时的不同规则，重载只是⼀种语⾔特性，与多态⽆关，与⾯向对象也⽆关，但这⼜是 C++中增加的新规则，所以也算属于 C++，所以如果⾮要说重载算是多态的⼀种，那就可以说：多态可以分为静态多态和动态多态。
静态多态其实就是重载，因为静态多态是指在编译时期就决定了调⽤哪个函数，根据参数列表来决定；
动态多态是指通过⼦类重写⽗类的虚函数来实现的，因为是在运⾏期间决定调⽤的函数，所以称为动态多态，
⼀般情况下我们不区分这两个时所说的多态就是指动态多态。动态多态的实现与虚函数表，虚函数指针相关。
扩展：⼦类是否要重写⽗类的虚函数？⼦类继承⽗类时， ⽗类的纯虚函数必须重写，否则⼦类也是⼀个虚类不可实例化。 定义纯虚函数是为了实现⼀个接⼝，起到⼀个规范的作⽤，规范继承这个类的程序员必须实现这个函数。

### 23、虚函数相关（虚函数表，虚函数指针），虚函数的实现原理
⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。
实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。
后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。
补充：如果基类中没有定义成 virtual，那么进⾏ Base B; Derived D; Base *p = D; p->function(); 这种情况下调⽤的则是 Base 中的 function()。因为基类和派⽣类中都没有虚函数的定义，那么编译器就会认为不⽤留给动态多态的机会，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派⽣类对象，⾸先要构造基类的空 间，然后构造派⽣类的⾃身内容，形成⼀个派⽣类对象，那么在进⾏类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数的地址，所以执⾏的是基类的函数。

### 简单说一下virtual关键字

### 24、编译器处理虚函数表应该如何处理
对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤：
拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表
当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基类
查看派⽣类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派⽣类是否有⾃身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中。

### 25、析构函数⼀般写成虚函数的原因
直观的讲：是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调
⽤基类的析构函数  （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的
⾃身内容将⽆法被析构，造成内存泄漏。
如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存。

### 26、构造函数为什么⼀般不定义为虚函数

虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体类型。但是，我们要创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；
⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函数表来调⽤虚函数，那么这个调⽤实际上也是违反了先实例化后调⽤的准则。

#### 27、构造函数或析构函数中调⽤虚函数会怎样
实际上是不应该在构造函数或析构函数中调⽤虚函数的，因为这样的调⽤其实并不会带来所想要的效果。
举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数 action_type()，在基类的构造函数中调⽤了这个虚函数。
 
派⽣类中重写了这个虚函数，我们期望着根据对象的真实类型不同，⽽调⽤各⾃实现的虚函数，但实际上当我们创建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法。
也就是说构造派⽣类的基类部分是，编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实现，并没有按照我们想要的⽅式进⾏。即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象。
在析构函数中也是同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那么在执⾏基类的析构函数中是不可能调⽤到派⽣类重写的⽅法的。所以说，我们不应该在构在函数或析构函数中调⽤虚函数，就算调⽤
⼀般也不会达到我们想要的结果。

### 28、析构函数的作⽤，如何起作⽤？
构造函数只是起初始化值的作⽤，但实例化⼀个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数⾥⾯，这样就使其他的函数⾥⾯有值了。规则，只要你⼀实例化对象，系统⾃动回调⽤⼀个构造函数，就是你不写，编译器也⾃动调⽤⼀次。
析构函数与构造函数的作⽤相反，⽤于撤销对象的⼀些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前⾯加~。
析构函数没有参数，也没有返回值，⽽且不能重载，在⼀个类中只能有⼀个析构函数。  当撤销对象时，编译器也会
⾃动调⽤析构函数。 每⼀个类必须有⼀个析构函数，⽤户可以⾃定义析构函数，也可以是编译器⾃动⽣成默认的析构函数。⼀般析构函数定义为类的公有成员。

### 29、构造函数的执⾏顺序？析构函数的执⾏顺序？
构造函数顺序
基类构造函数。如果有多个基类，则构造函数的调⽤顺序是某类在类派⽣表中出现的顺序，⽽不是它们在成员初始化表中的顺序。
成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象在类中被声明的顺序，⽽不是它们出现在成员初始化表中的顺序。
派⽣类构造函数。
析构函数顺序
调⽤派⽣类的析构函数；
调⽤成员类对象的析构函数；调⽤基类的析构函数。
30、纯虚函数 （应⽤于接⼝继承和实现继承）
实际上，纯虚函数的出现就是为了让继承可以出现多种情况：有时我们希望派⽣类只继承成员函数的接⼝
有时我们⼜希望派⽣类既继承成员函数的接⼝，⼜继承成员函数的实现，⽽且可以在派⽣类中可以重写成员函数以实现多态
有的时候我们⼜希望派⽣类在继承成员函数接⼝和实现的情况下，不能重写缺省的实现。
其实，声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化。
 
对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调⽤这个实现的唯⼀⽅式是在派⽣类对象中指出其 class 名称来调⽤。
31、静态绑定和动态绑定的介绍
说起静态绑定和动态绑定，我们⾸先要知道静态类型和动态类型，静态类型就是它在程序中被声明时所采⽤的类型，在编译期间确定。动态类型则是指“⽬前所指对象的实际类型”，在运⾏期间确定。
静态绑定，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发⽣在编译期间。动态绑定，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发⽣在运⾏期间。
⽐如说，virtual 函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们不应该重新定义继承⽽来的缺省参数，因为即使我们重定义了，也不会起到效果。因为⼀个基类的指针指向⼀个派⽣类对象，在派⽣类的对象中针对虚函数的参数缺省值进⾏了重定义， 但是缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内容，所以会出现⼀种派⽣类的虚函数实现⽅式结合了基类的缺省参数值的调⽤效果，这个与所期望的效果不同。
### 32、深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）
当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。
但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指ᰀ指针的问题。
所以，这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从
⽽也就解决来ᰀ指针的问题。简⽽⾔之，当数据成员中有指针时，必需要⽤深拷⻉更加安全。
33、什么情况下会调⽤拷⻉构造函数(三种情况)
类的对象需要拷⻉时，拷⻉构造函数将会被调⽤，以下的情况都会调⽤拷⻉构造函数：
⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中。
⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值。
⼀个对象需要通过另外⼀个对象进⾏初始化。
34、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？
为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构造函数⽣成⼀个副 本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就是⼀个⽆限递归。
35、结构体内存对⻬⽅式和为什么要进⾏内存对⻬？
⾸先我们来说⼀下结构体中内存对⻬的规则：
对于结构体中的各个成员，第⼀个成员位于偏移为  0  的位置，以后的每个数据成员的偏移量必须是
min(#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。
在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是  min(#pragma  pack()
制定的数，⻓度最⻓的数据成员的⻓度)  的倍数。
 
那么内存对⻬的作⽤是什么呢？
经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。
如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存 器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4 字节的数据进⼊寄存器，所以说，当内存没有对⻬时，寄存器进⾏了很多额外的操作，⼤⼤降低了 CPU 的性能。
另外，还有⼀个就是，有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对⻬还有利于平台移植。
36、内存泄漏的定义，如何检测与避免？
定义：内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。  它的⼀般表现⽅式是程序运⾏时间越
⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。
如何检测内存泄漏
⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。
37、说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）
⼆叉树：任何节点最多只允许有两个⼦节点，称为左⼦节点和右⼦节点，以
递归的⽅式定义⼆叉树为，⼀个⼆叉树如果不为空，便是由⼀个根节点和左右两个⼦树构成，左右⼦树都可能为空。
⼆叉搜索树：⼆叉搜索树可以提供对数时间的元素插⼊和访问。节点的放置规则是：任何节点的键值⼀定⼤于其左
⼦树的每⼀个节点的键值，并⼩于其右⼦树中的每⼀个节点的键值。因此⼀直向左⾛可以取得最⼩值，⼀直向右⾛可以得到最⼤值。插⼊：从根节点开始，遇键值较⼤则向左，遇键值较⼩则向右，直到尾端，即插⼊点。删除：如果删除点只有⼀个⼦节点，则直接将其⼦节点连⾄⽗节点。如果删除点有两个⼦节点，以右⼦树中的最⼩值代替要删除的位置。
平衡⼆叉树：其实对于树的平衡与否没有⼀个绝对的标准，“平衡”的⼤致意 思是：没有任何⼀个节点过深，不同的平衡条件会造就出不同的效率表现。以及不同的实现复杂度。有数种特殊结构例如 AVL-tree, RB-tree, AA-tree，均可以实现平衡⼆叉树。
AVL-tree ：⾼度平衡的平衡⼆叉树（严格的平衡⼆叉树）AVL-tree 是要求任何节点的左右⼦树⾼度相差最多为 1 的平衡⼆叉树。 当插⼊新的节点破坏平衡性的时候，从下往上找到第⼀个不平衡点，需要进⾏单旋转，或者双旋转进⾏调整。
 
38、说⼀下红⿊树（RB-tree）
红⿊树的定义：
性质1：每个节点要么是⿊⾊，要么是红⾊。性质2：根节点是⿊⾊。
性质3：每个叶⼦节点（NIL）是⿊⾊。
性质4：每个红⾊结点的两个⼦结点⼀定都是⿊⾊。
性质5：任意⼀结点到每个叶⼦结点的路径都包含数量相同的⿊结点。
39、说⼀下 define、const、typedef、inline 使⽤⽅法？
1、const 与 #define 的区别
const 定义的常量是变量带类型，⽽ #define 定义的只是个常数不带类型；
define 只在预处理阶段起作⽤，简单的⽂本替换，⽽ const 在编译、链接过程中起作⽤；
define 只是简单的字符串替换没有类型检查。⽽const是有数据类型的，是要进⾏判断的，可以避免⼀些低级错误；
define 预处理后，占⽤代码段空间，const  占⽤数据段空间；
const 不能重定义，⽽ define 可以通过 #undef 取消某个符号的定义，进⾏重定义；
define  独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。
2、#define 和别名 typedef 的区别
执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；#define 是宏定义，发⽣在预处理阶段，不进⾏类型检查；
功能差异，typedef  ⽤来定义类型的别名，定义与平台⽆关的数据类型，与 struct  的结合使⽤等。
#define  不只是可以为类型取别名，还可以定义常量、变量、编译开关等。
作⽤域不同，#define   没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。
⽽ typedef 有⾃⼰的作⽤域。
3、define 与 inline 的区别
#define是关键字，inline是函数；
宏定义在预处理阶段进⾏⽂本替换，inline  函数在编译阶段进⾏替换；
inline  函数有类型检查，相⽐宏定义⽐较安全；
扩展：
 
40、预处理，编译，汇编，链接程序的区别
⼀段⾼级语⾔代码经过四个阶段的处理形成可执⾏的⽬标⼆进制代码。 预处理器→编译器→汇编器→链接器：最难理解的是编译与汇编的区别。这⾥采⽤《深⼊理解计算机系统》的说法。
预处理阶段：写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如 #include<stdio.h> 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件。
编译阶段：编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是汇编语⾔程序。⾼级语⾔是源程序。所以注意概念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼级语⾔翻译的汇编语⾔相同。
汇编阶段：汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。
链接阶段：⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得到的是可执⾏⽬标⽂件。
41、说⼀下 fork，wait，exec 函数
⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内存。
当有进程写的时候使⽤写实拷⻉机制分配内存，exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进程就可以运⾏不同的程序了。
fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变，执⾏成功返回 0，错误返回 -1。
exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。
42、动态编译与静态编译
静态编译，编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；
动态编译，可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅
⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只
⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库，则⽤动态编译的可执⾏⽂件就不能运⾏。
43、动态链接和静态链接区别
静态连接库就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；动态链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。
 
静态链接库与动态链接库都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib 中的指令都全部被直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。
静态链接库和动态链接库的另外⼀个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。
动态库就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中有多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对 lib ⽂件中同⼀个函数的调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。
44、动态联编与静态联编
在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编和动态联编；
静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率
⾼，但灵活性差。
动态联编是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。
C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类的指针变量名->虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）
实现动态联编三个条件：
必须把动态联编的⾏为定义为类的虚函数；
类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；
必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； 哈喽，我是⼩贺哥，就爱分享编程知识，如果觉得⽂章对你有帮助，别忘记关注我哦！


1. 简单说一下C++当中的面向对象
说到⾯向对象，⼤家第⼀反应应该就是它的三⼤特性：封装性、继承性和多态性。那么我们先简单的了解⼀下这三⼤特性：
（1）封装性：封装，也就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让可信的类或者对象操作，对不可信的进⾏
信息隐藏。
在C++中类中成员的属性有：public， protected， private，这三个属性的访问权限依次降低。
（2）继承性：继承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。
（3）多态性：多态性（polymorphisn）是允许你将⽗对象设置成为和⼀个或更多的他的⼦对象相等的技术，赋值之后，⽗对象就可以根
据当前赋值给它的⼦对象的特性以不同的⽅式运作。简单的说，就是⼀句话：允许将⼦类类型的指针赋值给⽗类类型的指针。实现多态，有
⼆种⽅式，覆盖，重载。
覆盖，是指⼦类重新定义⽗类的虚函数的做法。
重载，是指允许存在多个同名函数，⽽这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
    在c++中函数名称相同，参数列表相同，返回值不同，算重载吗？
    重载最重要的是函数名称相同，函数的重载区分主要是靠参数列表来进行区分
    返回值不同是不能重载的，因为当调用的时候无法区分调用的是哪个函数

### C++中类的权限都有哪些，区别在哪里



## 第三章 STL容器和算法
## 第四章 C++11新特性

C++版本：C++有那些版本，更新了什么
## 第五章 数据结构和算法

1. 什么是数据结构？
数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合
大部分数据结构的实现都需要借助C语言中的指针和结构体类型

2. 常见的数据结构
（1）线性数据结构：元素之间一般存在元素之间存在一对一关系，是最常用的一类数据结构，典型的有：数组、栈、队列和线性表。
（2）树形结构：结点间具有层次关系，每一层的一个结点能且只能和上一层的一个结点相关，但同时可以和下一层的多个结点相关，称为“一对多”关系，常见类型有：树、堆。
（3）图形结构：在图形结构中，允许多个结点之间相关，称为“多对多”关系。

3. 简单介绍一下

a. 线性数据结构：数组，栈，队列和线性表
数组：存放着一组相同类型的数据，需要预先指定数组的长度，有一维数组、二维数组、多维数组等

b. 链表：链表是C语言中一种应用广泛的结构，它采用动态分配内存的形式实现，用一组任意的存储单元存放数据元素链表的，一般为每个元素增设指针域，用来指向后继元素

c. 数组和链表的区别：

从逻辑结构来看：数组必须事先定义固定的长度，不能适应数据动态地增减的情况；链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项（数组中插入、删除数据项时，需要移动其它数据项）

从内存存储来看：（静态)数组从栈中分配空间（用NEW创建的在堆中）, 对于程序员方便快速,但是自由度小；链表从堆中分配空间, 自由度大但是申请管理比较麻烦

从访问方式来看：数组在内存中是连续存储的，因此，可以利用下标索引进行随机访问；链表是链式存储结构，在访问元素的时候只能通过线性的方式由前到后顺序访问，所以访问效率比数组要低

数组的优点：随机访问性强、查找速度快
数组的缺点：插入和删除效率低、可能浪费内存、内存空间要求高，必须有足够的连续内存空间。数组大小固定，不能动态拓展
链表的优点：插入删除速度快、内存利用率高，不会浪费内存、大小没有固定，拓展很灵活。
链表的缺点：不能随机查找，必须从第一个开始遍历，查找效率低

（2）栈、队列和线性表：可采用顺序存储和链式存储的方法进行存储
顺序存储：借助数据元素在存储空间中的相对位置来表示元素之间的逻辑关系
链式存储：借助表示数据元素存储地址的指针表示元素之间的逻辑关系
a、栈：只允许在序列末端进行操作，栈的操作只能在栈顶进行，一般栈又被称为后进先出或先进后出的线性结构
　  顺序栈：采用顺序存储结构的栈称为顺序栈，即需要用一片地址连续的空间来存储栈的元素，顺序栈的类型定义如下：
　  链栈：采用链式存储结构的栈称为链栈：

b、队列：只允许在序列两端进行操作，一般队列也被称为先进先出的线性结构
　  循环队列：采用顺序存储结构的队列，需要按队列可能的最大长度分配存储空空，其类型定义如下：
　　链队列：采用链式存储结构的队列称为链队列，一般需要设置头尾指针只是链表的头尾结点：
c、线性表：允许在序列任意位置进行操作，线性表的操作位置不受限制，线性表的操作十分灵活，常用操作包括在任意位置插入和删除，以及查询和修改任意位置的元素

　 顺序表：采用顺序存储结构表示的线性表称为顺序表，用一组地址连续的存储单元一次存放线性表的数据元素，即以存储位置相邻表示位序相继的两个元素之间的前驱和后继关系，为了避免移动元素，一般在顺序表的接口定义中只考虑在表尾插入和删除元素，如此实现的顺序表也可称为栈表：
　线性表：一般包括单链表、双向链表、循环链表和双向循环链表
　单链表：
　双向链表：

　__线性表两种存储结构的比较__
　顺序表：
　优点：在顺序表中，逻辑中相邻的两个元素在物理位置上也相邻，查找比较方便，存取任一元素的时间复杂度都为O(1)
　缺点：不适合在任意位置插入、删除元素，因为需要移动元素，平均时间复杂度为O(n)

　链表：
　优点：在链接的任意位置插入或删除元素只需修改相应指针，不需要移动元素；按需动态分配，不需要按最大需求预先分配一块连续空空
　缺点：查找不方便，查找某一元素需要从头指针出发沿指针域查找，因此平均时间复杂度为O(n)
2、树形结构：结点间具有层次关系，每一层的一个结点能且只能和上一层的一个结点相关，但同时可以和下一层的多个结点相关，称为“一对多”关系，常见类型有：树、堆
（1）二叉树：二叉树是一种递归数据结构，是含有n(n>=0)个结点的有限集合，二叉树具有以下特点：
二叉树可以是空树；二叉树的每个结点都恰好有两棵子树，其中一个或两个可能为空；二叉树中每个结点的左、右子树的位置不能颠倒，若改变两者的位置，就成为另一棵二叉树
（2）完全二叉树：从根起，自上而下，自左而右，给满二叉树的每个结点从1到n连续编号，如果每个结点都与深度为k的满二叉树中编号从1至n的结点一一对应，则称为完全二叉树
a、采用顺序存储结构：用一维数组存储完全二叉树，结点的编号对于与结点的下标（如根为1，则根的左孩子为2*i=2*1=2，右孩子为2*i+1=2*1+1=2）
b、采用链式存储结构：
二叉链表：
三叉链表：它的结点比二叉链表多一个指针域parent，用于执行结点的双亲，便于查找双亲结点
两种存储结构比较：对于完全二叉树，采用顺序存储结构既能节省空间，又可利用数组元素的下标值确定结点在二叉树中的位置及结点之间的关系，但采用顺序存储结构存储一般二叉树容易造成空间浪费，链式结构可以克服这个缺点
（3）二叉查找树：二叉查找树又称二叉排序树，或者是一课空二叉树，或者是具有如下特征的二叉树：
a、若它的左子树不空，则左子树上所有结点的值均小于根结点的值
b、若它的右子树不空，则右子树上所有结点的值均大于根结点的值
c、它的左、右子树也分别是二叉查找树
（4）平衡二叉树：平衡二叉查找树简称平衡二叉树，平衡二叉树或者是棵空树，或者是具有下列性质的二叉查找树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差的绝对值不超过1
平衡二叉树的失衡及调整主要可归纳为下列四种情况：LL型、RR型、LR型、RL型
（5）树：树是含有n(n>=0)个结点的有限集合，在任意一棵非空树种：
a、有且仅有一个特定的称为根的结点
b、当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,...,Tm，其中每一个集合本身又是一棵树，并且T1,T2,...,Tm称为根的子树
（6）堆：堆是具有以下特性的完全二叉树，其所有非叶子结点均不大于（或不小于）其左右孩子结点。若堆中所有非叶子结点均不大于其左右孩子结点，则称为小顶堆（小根堆），若堆中所有非叶子结点均不小于其左右孩子结点，则称为大顶堆（大根堆）
（7）并查集：并查集是指由一组不相交子集所构成的集合，记作：S={S1,S2,S3,...,Sn}
（8）B树

3、图形结构：在图形结构中，允许多个结点之间相关，称为“多对多”关系，可分为有向图和无向图



## 第六章 操作系统
## 第七章 计算机网络
## 第八章 数据库
## 第九章 设计模式
## 第十章 QT和MFC

1. QT如何编写一个按钮事件
    第一步：给当前的页面添加一个按钮，找到该按钮的属性中的name即该按钮的名称
    第二步：在在引用的头文件（比如MainWindow.h）里加入槽的声明：
    ```.cpp {.line-numbers}
    public slots: 
    void on_pushButtonA_clicked();
    ``` 
    第三步：在调用处使用，（比如MainWindow.cpp）
    ``` .cpp {.line-numbers}
    void MainWindow::pushButtonA_clicked()
    {
        // 事件
        qDebug("pushButtonConnect");
    }
    ```

2. MFC如何编写一个按钮事件
   第一步：给当前页面添加一个按钮
   第二步：鼠标双击添加的按钮，按照向导来给按钮添加事件
   第三步：如何删除该按钮，都需要删除那些文件
        .h头文件中的函数声明，.cpp源代码中的函数实现，cpp文件中的ON_BN_CLICKED宏绑定代码
3. QT和MFC的区别
   1. QT是开源的，MFC是微软公司开发的
   2. QT是跨平台的，MFC主要是Windows上开发的
   3. QT的界面设计比MFC的要好
   4. QT的面向对象设计要比MFC好
   5. MFC无法创建大小动态可变的子窗口，必须手动修改窗口的位置，QT中，任何东西都可以手动敲出来


## 第十一章 版本管理

Q1。什么是版本控制？
它是一个记录一段时间内对一个文件或一组文件的更改的系统，以便您以后可以调用特定版本。
版本控制系统由一个中央共享存储库组成，同事可以在其中对文件或文件集进行更改。
版本控制可让您：
将文件还原到以前的状态。
将整个项目还原到以前的状态。
比较随时间的变化。
查看谁最后修改了可能导致问题的内容。
谁修改了问题，何时修改了。



### 1. 常用的版本管理工具都有哪些
    git，SVN

### 什么是git
Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。
### 2. Git和SVN的区别是什么？

    a. Git是分布式的，⽽SVN不是分布式的
    b. Git把内容按元数据⽅式存储，⽽SVN是按⽂件
    c. Git的内容的完整性要优于SVN
    d. SVN只能有⼀个指定中央版本库。⽽ Git可以有⽆限个版本库。

### 3. SVN优缺点？

    优点
    a. 管理⽅便，逻辑明确，符合⼀般⼈思维习惯。
    b. 易于管理，集中式服务器更能保证安全性。
    代码⼀致性⾮常⾼。
适合开发⼈数不多的项⽬开发。
缺点：
服务器压⼒太⼤，数据库容量暴增。
如果不能连接到服务器上，就不能提交，还原，对⽐等等。
不适合开源开发。但是⼀般集中式管理的有⾮常明确的权限管理机制（例如分⽀访问限制），可以实现分层管理，从⽽很好的解决开发⼈数众
多的问题。

### 4. Git优缺点？
优点：
适合分布式开发，强调个体。
公共服务器压⼒和数据量都不会太⼤。
速度快、灵活。
任意两个开发者之间可以很容易的解决冲突。
离线⼯作。
缺点：
代码保密性差，⼀旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。

说⼀下Git合并的两种⽅法以及区别？
Git代码合并有两种：
和 
Git Merge
Git ReBase
Git Merge：
这种合并⽅式是将两个分⽀的历史合并到⼀起，现在的分⽀不会被更改，它会⽐对双⽅不同的⽂件缓存下来，⽣成⼀个commit，去push。
Git ReBase：
这种合并⽅法通常被称为“衍合”。他是提交修改历史，⽐对双⽅的commit，然后找出不同的去缓存，然后去push，修改commit历史。

### 3. 举例你提交代码的一个流程

### 4. Git中如何解决冲突的问题

## 第十二章 其他

1. 简历模板
2. Office的教程
3. C++代码规范
4. 代码图片
5. Markdown
6. 思维导图

## 第十三章 简历中的项目介绍
